snippet for "for loop" b
for (int ${1:i} = ${2:0}; $1 < $3; ++$1)
{
	$4
}
endsnippet

snippet fori "fori loop" b
for (int i = 0; i < ${1:m}; ++i)
{
	$2
}
endsnippet

snippet forj "forj loop" b
for (int j = 0; j < ${1:n}; ++j)
{
	$2
}
endsnippet

snippet class "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`}
{
	public:
		${1/(\w+).*/$1/} (${2:arguments});
		virtual ~${1/(\w+).*/$1/} ();

	private:
		${0:/* data */}
};
endsnippet

snippet fnc "Basic c++ doxygen function template" b
/**
* @brief: ${4:brief}
*
* @param: `!p write_docstring_args(t[3],snip)`
*
* @return: `!p snip.rv = t[1]`
*/
${1:ReturnType} ${2:FunctionName}(${3:param})
{
	${0:FunctionBody}
}
endsnippet

snippet func "C++ function" b
${1:ReturnType} ${2:FunctionName}(${3:param})
{
	${0:FunctionBody}
}
endsnippet

snippet map "map (m_map)"
map<${1:key},${2:value}> m_map$0;
endsnippet

snippet vector "vector (arr)"
vector<${1:int}> arr$0;
endsnippet

snippet queue "queue (m_que)"
queue<${1:int}> m_que$0;
endsnippet

snippet deque "deque (m_deque)"
deque<${1:int}> m_deque$0;
endsnippet

snippet stack "stack (stk)"
stack<${1:int}> stk$0;
endsnippet

snippet vecvec "vecvec (arr)"
vector<vector<${1:int}>> arr$0;
endsnippet

snippet while "while n--" b
while(${1:n--})
{
	$2
}
endsnippet

snippet lamda "lamda expression"
[&](${1:int} a,${2:int} b)->bool {return a<b;}
endsnippet

snippet dfs "graph DFS" b
dfs(graph,isVisited,curX,curY,oneAns,ans)
endsnippet

snippet bfs "queue-based Tree BFS" b 
m_que.push(root);
while(m_que.empty()==false)
{
	int cnt = m_que.size();
	for(int i=0;i<cnt;++i)
	{
		auto curNode = m_que.front();
		m_que.pop();
		${1:cout << curNode->val << endl;}
		if( curNode->left )
			m_que.push(curNode->left);
		if( curNode->right )
			m_que.push(curNode->right);
	}
}
endsnippet

snippet switch "switch case" b 
switch(${1:VALUE})
{
	case 0:
		${2:do something;}
		break;
	case 1:
	case 2:
		${3:do something;}
		break;
	default:
		break;
} 
endsnippet
snippet if "if(...)" b
if($1)
{
	$2
}
endsnippet
